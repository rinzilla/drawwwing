<!DOCTYPE html>
<html>
<head>
    <title>Telegram Draw Bot</title>
    <style>
        body { font-family: Arial; text-align: center; }
        canvas { border: 1px solid #000; margin: 10px; }
        .tools { margin: 10px; }
        button { padding: 5px 10px; margin: 5px; }
        .history-buttons { margin-top: 10px; }
    </style>
</head>
<body>
    <h1>üé® –†–∏—Å–æ–≤–∞–ª–∫–∞ –¥–ª—è Telegram</h1>
    <div class="tools">
        <input type="color" id="colorPicker" value="#000000">
        <button onclick="changeSize(2)">–¢–æ–Ω–∫–∞—è</button>
        <button onclick="changeSize(10)">–°—Ä–µ–¥–Ω—è—è</button>
        <button onclick="changeSize(20)">–¢–æ–ª—Å—Ç–∞—è</button>
        <button onclick="toggleEraser()">–õ–∞—Å—Ç–∏–∫</button>
        <button onclick="activateFill()">–ó–∞–ª–∏–≤–∫–∞</button>
        <button onclick="clearCanvas()">–û—á–∏—Å—Ç–∏—Ç—å</button>
        <button onclick="saveImage()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </div>
    <div class="history-buttons">
        <button onclick="undo()">‚Ü©Ô∏è Undo</button>
        <button onclick="redo()">‚Ü™Ô∏è Redo</button>
    </div>
    <canvas id="drawCanvas" width="500" height="500"></canvas>

    <script>
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let currentColor = '#000000';
        let currentSize = 5;
        let isErasing = false;
        let isFilling = false;

        // –ò—Å—Ç–æ—Ä–∏—è –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è Undo/Redo
        let history = [];
        let historyIndex = -1;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ö–æ–ª—Å—Ç–∞
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        saveState();

        // –ü–æ–ª—É—á–∞–µ–º chat_id –∏–∑ URL
        const urlParams = new URLSearchParams(window.location.search);
        const chatId = urlParams.get('chat_id');

        function changeColor(color) { 
            currentColor = color;
            isErasing = false;
            isFilling = false;
        }

        function changeSize(size) { 
            currentSize = size; 
        }

        function toggleEraser() {
            isErasing = true;
            isFilling = false;
        }

        function activateFill() {
            isFilling = true;
            isErasing = false;
        }

        function clearCanvas() { 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState();
        }

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é
        function saveState() {
            history = history.slice(0, historyIndex + 1);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            history.push(imageData);
            historyIndex++;
        }

        // –û—Ç–º–µ–Ω–∞ –¥–µ–π—Å—Ç–≤–∏—è (Undo)
        function undo() {
            if (historyIndex <= 0) return; // –ù–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            historyIndex--;
            ctx.putImageData(history[historyIndex], 0, 0);
        }

        // –ü–æ–≤—Ç–æ—Ä –¥–µ–π—Å—Ç–≤–∏—è (Redo)
        function redo() {
            if (historyIndex >= history.length - 1) return; // –ù–µ–ª—å–∑—è –ø–æ–≤—Ç–æ—Ä–∏—Ç—å
            historyIndex++;
            ctx.putImageData(history[historyIndex], 0, 0);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        function startDrawing(e) {
            isDrawing = true;
            if (isFilling) {
                floodFill(e.offsetX, e.offsetY, currentColor);
                saveState();
            } else {
                draw(e);
            }
        }

        function draw(e) {
            if (!isDrawing || isFilling) return;
            
            ctx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
            ctx.lineWidth = currentSize;
            ctx.lineCap = 'round';
            ctx.strokeStyle = isErasing ? 'rgba(0,0,0,1)' : currentColor;
            
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(e.offsetX, e.offsetY);
        }

        function stopDrawing() {
            if (isDrawing && !isFilling) {
                saveState();
            }
            isDrawing = false;
            ctx.beginPath();
        }

        // –ó–∞–ª–∏–≤–∫–∞ –æ–±–ª–∞—Å—Ç–∏ (flood fill)
        function floodFill(x, y, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixelStack = [[x, y]];
            const targetColor = getPixelColor(imageData, x, y);
            const fillRgb = hexToRgb(fillColor);
            
            if (colorsMatch(targetColor, fillRgb)) return;

            while (pixelStack.length) {
                const [x, y] = pixelStack.pop();
                const pixelPos = (y * canvas.width + x) * 4;
                
                if (colorsMatch(getPixelColor(imageData, x, y), targetColor)) {
                    setPixelColor(imageData, pixelPos, fillColor);
                    
                    if (x > 0) pixelStack.push([x - 1, y]);
                    if (x < canvas.width - 1) pixelStack.push([x + 1, y]);
                    if (y > 0) pixelStack.push([x, y - 1]);
                    if (y < canvas.height - 1) pixelStack.push([x, y + 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∑–∞–ª–∏–≤–∫–∏
        function getPixelColor(imageData, x, y) {
            const pos = (y * canvas.width + x) * 4;
            return {
                r: imageData.data[pos],
                g: imageData.data[pos + 1],
                b: imageData.data[pos + 2],
                a: imageData.data[pos + 3]
            };
        }

        function setPixelColor(imageData, pos, hexColor) {
            const rgb = hexToRgb(hexColor);
            imageData.data[pos] = rgb.r;
            imageData.data[pos + 1] = rgb.g;
            imageData.data[pos + 2] = rgb.b;
            imageData.data[pos + 3] = 255;
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function colorsMatch(c1, c2) {
            return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b;
        }

        // –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Telegram
        async function saveImage() {
            if (!chatId) {
                alert("–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω ID —á–∞—Ç–∞!");
                return;
            }
            
            const image = canvas.toDataURL('image/png');
            const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: chatId,
                    photo: image.split(',')[1]
                })
            });
            
            if (response.ok) {
                alert("–ö–∞—Ä—Ç–∏–Ω–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ –≥—Ä—É–ø–ø—É!");
            } else {
                alert("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏!");
            }
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –≤ –ø–∞–ª–∏—Ç—Ä–µ
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            changeColor(e.target.value);
        });
    </script>
</body>
</html>
